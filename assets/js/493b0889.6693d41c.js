"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[540],{1285:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>a});var t=o(3303);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},9596:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"techniques/sharding","title":"Sharding","description":"Discord prevents your bot application from logging in without sharding once you hit a scale of 2,500 guilds. If you are not planning to create a public bot application, then you can go ahead and ignore this section. However, if you are creating a public bot application, it would be wise to keep sharding in mind as it can increase the complexity of your application due to how a sharded process works.","source":"@site/content/techniques/sharding.mdx","sourceDirName":"techniques","slug":"/techniques/sharding","permalink":"/techniques/sharding","draft":false,"unlisted":false,"editUrl":"https://github.com/GlobalArtInc/nestcord/tree/master/docs/content/techniques/sharding.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"sharding","title":"Sharding","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Validation","permalink":"/techniques/validation"},"next":{"title":"Async Configuration","permalink":"/techniques/async-configuration"}}');var i=o(7711),s=o(1285);const r={id:"sharding",title:"Sharding",sidebar_position:1},a=void 0,c={},d=[];function h(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Discord prevents your bot application from logging in without sharding once you hit a scale of 2,500 guilds. If you are not planning to create a public bot application, then you can go ahead and ignore this section. However, if you are creating a public bot application, it would be wise to keep sharding in mind as it can increase the complexity of your application due to how a sharded process works."}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["If you are running the bot as part of a webserver within NestJS, then in order to implement sharding you must understand that initialising ",(0,i.jsx)(n.code,{children:"nestcord"})," within your HTTP server process isn't going to be a viable option. So we're going to have to split the two into their own independent processes. This doesn't mean you can't share code between the two, just that they will be running on different processes. You could consider your \"bot\" application as a microservice of sorts."]})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["In your ",(0,i.jsx)(n.code,{children:"src"})," directory, create a new ",(0,i.jsx)(n.code,{children:"bot.ts"})," file, this will be used to instantiate the bot as a standalone application wth some slight differences. The ",(0,i.jsx)(n.code,{children:"DiscordModule"})," cannot be imported within your ",(0,i.jsx)(n.code,{children:"AppModule"}),". This is because we do not want any bot processes on unsharded processes, so if you need to share code between the two, you should import the necessary modules into your ",(0,i.jsx)(n.code,{children:"DiscordModule"})," or alternatively, create a ",(0,i.jsx)(n.code,{children:"SharedModule"})," which is imported both into your ",(0,i.jsx)(n.code,{children:"AppModule"})," and ",(0,i.jsx)(n.code,{children:"DiscordModule"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { NestFactory } from '@nestjs/core';\nimport { DiscordModule } from './discord/discord.module';\n\nasync function bootstrap() {\n    await NestFactory.createApplicationContext(DiscordModule);\n}\n\nbootstrap();\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["You may also need to add a ",(0,i.jsx)(n.code,{children:"webpack.config.js"})," file to your root directory which exports the ",(0,i.jsx)(n.code,{children:"bot.ts"})," file as it's not automatically exported with the application due to how the ",(0,i.jsx)(n.code,{children:"bot.ts"})," file is used within another process which webpack is unable to detect. You can use the following snippet to achieve this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const Path = require('path');\n\nmodule.exports = function (options) {\n    return {\n        ...options,\n        entry: {\n            main: options.entry,\n            bot: Path.join(__dirname, 'src', 'bot.ts')\n        },\n        output: {\n            filename: '[name].js'\n        }\n    };\n};\n"})})]}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["Modify your ",(0,i.jsx)(n.code,{children:"main.ts"})," file to create a new ",(0,i.jsx)(n.code,{children:"ShardingManager"})," instance which calls your ",(0,i.jsx)(n.code,{children:"bot.js"})," file (not .ts extension), specifying a .ts extension will cause errors as this is executed only after your code has been transpiled into JavaScript. You can use the snippet below as an example:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport * as Path from 'path';\n\nexport async function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    const port = 80;\n\n    await app.listen(port);\n\n    const manager = new ShardingManager(Path.join(__dirname, 'bot.js'), {\n        token: 'secret'\n    });\n\n    manager.spawn();\n\n    manager.on('shardCreate', shard => {\n        shard.on('reconnecting', () => {\n            console.log(`Reconnecting shard: [${shard.id}]`);\n        });\n\n        shard.on('spawn', () => {\n            console.log(`Spawned shard: [${shard.id}]`);\n        });\n\n        shard.on('ready', () => {\n            console.log(` Shard [${shard.id}] is ready`);\n        });\n\n        shard.on('death', () => {\n            console.log(`Died shard: [${shard.id}]`);\n        });\n\n        shard.on('error', err => {\n            console.log(`Error in  [${shard.id}] with : ${err} `);\n            shard.respawn();\n        });\n    });\n}\nbootstrap();\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["Now when you bootstrap your application, your ",(0,i.jsx)(n.code,{children:"bot.ts"})," context is created on a sharded process."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["If you are running into further issues and require cross-hosting your bot application, then just swap the ",(0,i.jsx)(n.code,{children:"ShardingManager"})," out for other sharding packages like the ",(0,i.jsx)(n.a,{href:"https://github.com/meister03/discord-hybrid-sharding",children:"discord-hybrid-sharding"})," which is required for the ",(0,i.jsx)(n.a,{href:"https://github.com/meister03/discord-cross-hosting",children:"discord-cross-hosting"})," package."]})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);