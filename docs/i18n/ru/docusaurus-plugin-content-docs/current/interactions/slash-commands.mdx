---
id: команды слэша
title: Слэш команды
sidebar_position: 1
---

**Слэш команды** новый, захватывающий способ создания и взаимодействия с ботами в **Discord**. With Slash Commands, all you have to do is
type `/` and you're ready to use your favorite bot. Вы можете легко увидеть все команды, которые имеет бот, а также проверить и поработать с ошибками
вы получаете команду в первый раз.

## Глобальные команды

:::tip

Глобальные команды кэшируются на один час. Новые глобальные команды медленно разгонятся во всех гильдиях и гарантированно будут обновлены
только через час. Команды гильдии обновляются мгновенно. As such, we recommend you use guild-based commands during development and publish them to
global commands when they're ready for public use.

[Подробнее о конфигурации dev-mode](/start#development)
:::

Создайте файл `app.commands.ts` и добавьте метод с декоратором `SlashCommand`.

```typescript title="src/app.commands.ts"
import { Injectable } from '@nestjs/common';
import { Context, SlashCommand, SlashCommandContext } from '@globalart/nestcord';

@Injectable()
export class AppCommands {
    @SlashCommand({
        name: 'ping',
        description: 'Ping-Pong Command'
    })
    public async onPing(@Context() [interaction]: SlashCommandContext) {
        return interaction. eply({ content: 'Pong!' });
    }
}
```

## Команды гильдии

Если вы хотите иметь специфические команды для гильдии, используйте свойство `guilds` на декораторе `SlashCommand`

```typescript title="src/app.commands.ts"
import { Injectable } from '@nestjs/common';
import { Context, SlashCommand, SlashCommandContext } from '@globalart/nestcord';

@Injectable()
export class AppCommands {
    @SlashCommand({
        name: 'ping',
        описание: 'Команда Ping-Pong',
        гильдий: [process.env.DEV_GUILD]
    })
    public async onPing(@Context() [interaction]: SlashCommandContext) {
        return interaction. eply({ content: 'Pong!' });
    }
}
```

> Можно использовать декоратор как по методу, так и по классу.

## Варианты

Используйте декоратор опций для определения параметра в комманде слэша, давайте создадим класс «LengthDto»:

```typescript title="length.dto.ts"
import { StringOption } из '@globalart/nestcord';

export class TextDto {
    @StringOption({
        name: 'text',
        description: 'Your text',
        required: true
    })
    текст: строка;
}
```

У него только одно базовое свойство. После этого мы можем использовать только что созданный DTO внутри `AppCommands`:

```typescript title="app.commands.ts"
import { Injectable } from '@nestjs/common';
import { Context, SlashCommand, Options, SlashCommandContext } from '@globalart/nestcord';
import { TextDto } from './length. to';

@Injectable()
export class AppCommands {
    @SlashCommand({
        name: 'length',
        description: 'Get length of text'
    })
    public async onLength(@Context() [interaction]: SlashCommandContext, @Options() { text }: TextDto) {
        return interaction. eply({content: `Длина текста ${text.length}`});
    }
}
```

Список встроенных декораторов опций:

| Декоратор                 | Тип                                   | Описание                        |
| :------------------------ | :------------------------------------ | :------------------------------ |
| `StringOption`            | `строка`                              | Опция строки                    |
| «Вариант количества»      | `number`                              | Вариант числа                   |
| `IntegerOption`           | `number`                              | Вариант целочисленного числа    |
| `BooleanOption`           | `boolean`                             | Логическая опция                |
| `UserOption`              | `Пользователь`                        | Опция пользователя              |
| `MemberOption`            | «Участник гильдии»                    | Вариант участника               |
| `ChannelOption`           | `GuildChannel`                        | Вариант канала                  |
| `Опция роля`              | `Роль`                                | Вариант роли                    |
| `MentionableOption`       | `GuildMember` \| `Role` \| `User`     | Упоминаемый вариант             |
| `Опция вложения`          | `Опция вложения`                      | Опция вложения                  |

## Автозаполнение

Чтобы добавить автозаполнение к вашей команде Slash, вам сначала понадобится перехватчик. Этот класс перехватит все запросы пользователя после ввода в поле опции автозаполнения

```typescript title="anime.interceptor.ts"
import { Injectable } from '@nestjs/common';
import { AutocompleteInteraction } from 'discord. s';
импортировать { AutocompleteInterceptor } из '@globalart/nestcord';

@Injectable()
класс AnimeAutocompleteInterceptor расширяет AutocompleteInterceptor {
    public transformOptions(interaction: AutocompleteInteraction) {
        const focused = interaction. ptions.getFocused(true);
        let choices: string[];

        if (focused. ame === 'anime') {
            выбор = ['Хантер x Охотник', 'Наруто', 'One Piece'];
        }

        возврат взаимодействия. espond(
            выбора
                . ilter(choice => choice.startsWith(focused.value.toString()))
                . ap(выбор => ({ name: choice, value: choice }))
        );
    }
}
```

Затем вам нужно добавить `autocomplete: true` к вашему классу опций:

```typescript title="anime.dto.ts"
import { StringOption } из '@globalart/nestcord';

export class AnimeDto {
    @StringOption({
        name: 'anime',
        описание: «Аниме для поиска»,
        автозаполнение: true,
        необходимо: true
    })
    анимация: строка;
}
```

И последнее, но не менее важное, примените перехватчика к вашей команде слэша

```typescript title="anime-commands.service.ts"
import { Injectable, UseInterceptors } from '@nestjs/common';
import { Context, SlashCommand, Options, SlashCommandContext } from '@globalart/nestcord';
import { AnimeDto } from '/anime. to';
импортировать { AnimeAutocompleteInterceptor } из './anime. nterceptor;

@Injectable()
export class AnimeCommands {
    @UseInterceptors(AnimeAutocompleteInterceptor)
    @SlashCommand({
        name: 'anime',
        description: 'Lookup information about an anime'
    })
    public async onSearch(@Context() [interaction]: SlashCommandContext, @Options() { anime }: AnimeDto) {
        return interaction. eply({content: `Я нашел аниме ${anime}`});
    }
}
```

## Группы

:::tip **TIP**

Для тех разработчиков, которые хотят сделать более организованными и сложными группами команд, выглядите не дальше, чем подгруппы и группы.
:::

Используйте декораторы `SlashGroup` на уровне класса `(Group)` и методе `(SubGroup)`:

```typescript title="utils-commands.service.ts"
импортировать {createCommandGroupDecorator, Subcommand} из '@globalart/nestcord';

export const UtilsCommandDecorator = createCommandGroupDecorator({
    name: 'utils',
    description: 'Utils group',
});

@UtilsCommandDecorator()
export class UtilsCommands {
    @Subcommand({
        name: 'ping',
        description: 'Ping-pong command'
    })
    public async onPing(. .) {
    ...
    }
}

@UtilsCommandDecorator({
    name: 'string',
    descriptionn: 'String utility commands'
})
класса экспорта UtilsStringCommands {
    @Subcommand({
        name: 'length',
        description: 'String length command'
    })
    public async onLength(. .) {
    ...
    }
}


```
