---
id: локализация
title: Локализация
sidebar_position: 2
---

Легкий модуль локализации для [NestCord](https://nestcord.js.org/). It allows you to easily localize your bot's
commands and messages. Модуль предоставляет простой API для управления локалями и переводами, а также мощный адаптер локализации
системы.

## Использование

После завершения установки мы можем импортировать `NestCordLocalizationModule` с вашим `NestCordModule` в корень `AppModule`:

```typescript
import { NestCordModule } from '@globalart/nestcord';
import { Module } from '@nestjs/common';
import { NestCordLocalizationModule, DefaultLocalizationAdapter, UserResolver } from '@globalart/nestcord';
import { AppService } from '. приложение. ervice';

@Module({
    imports: [
        NestCordModule. orRoot({
            токен: процесс. nv.DISCORD_TOKEN,
            intents: [
                IntentsBitField. лага. uilds,
                IntentsBitField.Flags. irectMessages,
                IntentsBitField.Flags. UildMembers,
                IntentsBitField.Flags. uildMessages,
                IntentsBitField. lags.MessageContent
            ],
            префикс: '! ,
            разработка: [process.env.DISCORD_TEST_GUILD]
        }),
        NestCordLocalizationModule. orRoot({
            resolvers: UserResolver,
            // Также вы можете предоставить класс для поддержки injection через @Inject
            адаптер: new DefaultLocalizationAdapter({
                fallbackLocale: 'en-US',
                locales: {
                    'en-US': {
                        'commands. ing.name': 'ping',
                        'команды. вообще. escription': 'Понг!
                    },
                    ru: {
                        'команды. ing.name': 'пинг',
                        команды. вообще. escription': 'Понг!
                    }
                }
            })
        })
    ],
    провайдеров: [AppService]
})
класс экспорта AppModule {
}
```

## Адаптеры

`DefaultLocalizationAdapter` является простым адаптером, который позволяет предоставить карту локалей и переводов.

Также вы можете использовать `NestedLocalizationAdapter`, который позволяет разбивать ключи перевода на объекты

```typescript
импорт { NestCordLocalizationModule, NestedLocalizationAdapter, UserResolver } из '@globalart/nestcord/localization';

NestCordLocalizationModule. orRoot({
    resolvers: UserResolver,
    адаптер: new NestedLocalizationAdapter({
        fallLocale: 'en-US',
        locales: {
            'en-US': {
                'commands': {
                    'ping': {
                        'name': 'ping',
                        'description': 'Pong!
                    }
                }
            },
            ru: {
                'commands': {
                    'ping': {
                        'name': 'пинг',
                        'description': 'Понг!
                    }
                }
            }
        }
    })
})

```

:::info
`DefaultLocalizationAdapter` и `NestedLocalizationAdapter` могут перевести строки и заполнители локализации (например `{{username}}`)
:::

#### Пользовательские адаптеры

Также вы можете создать свой собственный адаптер локализации. Просто реализуйте интерфейс «BaseLocalizationAdapter»:

```typescript
импорт { BaseLocalizationAdapter } из '@globalart/nestcord/localization';

интерфейс CustomLocalizationOptions {
    fallbackLocale: string;
    locales: Record<string, Record<string, string>>;
}

export class CustomLocalizationAdapter extends BaseLocalizationAdapter<CustomLocalizationOptions> {
    public getTranslation(key: string, locale: string, . .args: unknown[]): string {
        return `${key} by ${locale}`;
    }
}
```

## Резолверы

Резолверы используются для получения локали для перевода. По умолчанию, NestCord предоставляет два резолвера: `UserResolver` и `GuildResolver`.

| Резолвер               | Описание                                                                     |
| ---------------------- | ---------------------------------------------------------------------------- |
| Резолвер пользователя  | Получает локаль из свойства локали пользователя (`interaction.locale`)       |
| Резольвер гильдии      | Получает локаль из локального свойства гильдии (`interaction.guildLocale`)   |

#### Пользовательские Резолверы

Также вы можете создать свой собственный Резольвер. Просто выполните `LocaleResolver` интерфейс:

```typescript
import { CommandContext, LocaleResolver } from '@globalart/nestcord';
import { ExecutionContext, Injectable } from '@nestjs/common';
import { NestCordExecutionContext } from '@globalart/nestcord';

@Injectable()
export class GuildResolver implements LocaleResolver {
    resolve(context: ExecutionContext): string | string[] | undefined {
        const nestcordContext = NestCordExecutionContext. reate(context);
        const [interaction] = nestcordContext. etContext<CommandContext>();

        return interaction.guildLocale;
    }
}
```

## Локализация

Мы можем вставить `LOCALIZATION_ADAPTER` в наш сервис и использовать его для локализации наших команд и сообщений:

```typescript title="src/app.gateway.ts"
import { Injectable, Inject, OnModuleInit } from '@nestjs/common';
import { DefaultLocalizationAdapter, localizationMapByKey, LOCALIZATION_ADAPTER } from '@globalart/nestcord';
import { Context, SlashCommand, SlashCommandContext } from '@globalart/nestcord';

@Injectable()
export class AppService implements OnModuleInit {
    public constructor(
        @Inject(LOCALIZATION_ADAPTER)
        private readonly localizationAdapter: DefaultLocalizationAdapter
    ) {
    }

    @SlashCommand({
        name: 'ping',
        описание: 'Понг! ,
        Локализаций: localizationMapByKey('команды. ing.name'),
        descriptionLocalizations: localizationMapByKey('commands.ping. ame')
    })
    public ping(@Context() [interaction]: SlashCommandContext) {
        const message = this. ocalizationAdapter.getTranslation(
            'команд. ing.description', Взаимодействие
            . ocale
        );
        возвращающее взаимодействие. eply(сообщение);
    }
}
```

Или вы можете использовать функцию `translate` из адаптера локализации:

```typescript title="src/app.gateway.ts"
import { Injectable, Inject, OnModuleInit } from '@nestjs/common';
import { DefaultLocalizationAdapter, localizationMapByKey, LOCALIZATION_ADAPTER } from '@globalart/nestcord';
import { Context, SlashCommand, SlashCommandContext } from '@globalart/nestcord';

@Injectable()
export class AppService implements OnModuleInit {
    public constructor(
        @Inject(LOCALIZATION_ADAPTER)
        private readonly localizationAdapter: DefaultLocalizationAdapter
    ) {
    }

    @SlashCommand({
        name: 'ping',
        описание: 'Понг! ,
        Локализаций: localizationMapByKey('команды. ing.name'),
        descriptionLocalizations: localizationMapByKey('commands.ping. ame')
    })
    public ping(@Context() [interaction]: SlashCommandContext) {
        const message = this. ocalizationAdapter.translate(
            'commands.ping. escription',
        );
        обратное взаимодействие. eply(сообщение);
    }
}
```

Или вы можете использовать декоратор `@CurrentTranslate` для получения текущего перевода из контекста:

```typescript
импортировать { Injectable, Inject, OnModuleInit } из '@nestjs/common';
import { DefaultLocalizationAdapter, CurrentTranslate, localizationMapByKey, TranslationFn } из '@globalart/nestcord/localization';
импорт { Context, SlashCommand, SlashCommandContext } из '@globalart/nestcord';

@Injectable()
export class AppService implements OnModuleInit {
    @SlashCommand({
        name: 'ping',
        описание: 'Понг! ,
        Локализации: localizationMapByKey('commands. ing.name'),
        Описание Локализации: localizationMapByKey('commands.ping. ame')
    })
    публичных ping(
        @Context() [interaction]: SlashCommandContext,
        @CurrentTranslate() t: TranslationFn
    ) {
        const message = t('commands. ing.description');
        return interaction.reply(message);
    }
}
```

:::info
Функция `localizationMapByKey` используется для локализации имени и описания команды. You pass the translation key or localization map as
an argument to the function.
:::

#### Настройка локализованных команд

Вы можете установить, какие локали будет локализована команда

```typescript
@SlashCommand({
    name: 'ping',
    description: 'Pong!',
    nameLocalizations: localizationMapByKey('commands.ping.name', ['ru', 'ru']),
    descriptionLocalizations: localizationMapByKey('commands.ping.name', ['ru'])
})
```

Или просто передайте объект локализации с идентификатором местоположения и ключом перевода в свойства `nameLocalization` и `descriptionLocalizations`

```typescript
@SlashCommand({
    name: 'ping',
    description: 'Pong!',
    nameLocalizations: {
        en: 'command.ping.name',
        ru: 'command.ping.name'
    },
    descriptionLocalizations: {
        en: 'command.ping.description',
        ru: 'command.ping.description'
    }
})
```

## Обновить локализацию без перезапуска приложения

Если вы получаете переводы из внешнего API, например, crowdin, weblate или другой службы переводов.
Вы можете обновить его просто вызвать `localizationService`

```typescript
import {
  Context,
  NestCordLocalizationService,
  SlashCommand,
  SlashCommandContext,
} from '@globalart/nestcord';

export class AppService {
  constructor(
    private readonly nestCordLocalizationService: NestCordLocalizationService,
  ) {}

  @SlashCommand({
    name: 'update_translations',
    description: 'Update translations',
  })
  updateTranslations(@Context() [interaction]: SlashCommandContext) {
    // Получение данных из API

    этого. LocalizationService. pdateLocales({
      // статические переводы для теста или вы можете поместить его из API
      'en-US': {
        'commands.ping.description': 'My new translation',
      },
    });

    взаимодействие возврата. eply({ content: "Обновлено успешно" });
  }
}
```

Поздравляем! Вы успешно создали свою первую локализованную команду с NestCord!
