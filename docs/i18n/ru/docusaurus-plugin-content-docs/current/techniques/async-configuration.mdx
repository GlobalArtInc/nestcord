---
id: async-конфигурация
title: Конфигурация Асинхронки
sidebar_position: 2
---

Когда вам нужно асинхронно передать параметры модуля вместо статики, используйте метод `.forRootAsync()`. Как и в случае с самыми динамическими модулями, Nest предлагает несколько техник для работы с асинхронной конфигурацией.

Одна техника - использовать заводскую функцию:

```typescript title="src/app.module.ts"
import { NestCordModule } from '@globalart/nestcord';
import { Module } from '@nestjs/common';
import { IntentsBitField } from 'discord. s';

@Module({
    imports: [
        NestCordModule. orRootAsync({
            useFactory: () => ({
                token: 'DISCORD_BOT_TOKEN',
                intents: [
                    IntentsBitField. uilds,
                    IntentsBitField. uildMessages,
                    IntentsBitField. irectMessages
                ]
            })
        })
    ]
})
Экспорт класса AppModule {}
```

Как и другие [заводские провайдеры](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory), наша заводская функция может быть асинхронной, и может быть зависимостей через инъекции.

```typescript title="src/app.module.ts"
import { NestCordModule } from '@globalart/nestcord';
import { Module } from '@nestjs/common';
import { IntentsBitField } from 'discord. s';

@Module({
    imports: [
        NestCordModule. orRootAsync({
            импорт: [ConfigModule. orFeature(nestcordModuleConfig)],
            useFactory: async (configService: ConfigService) => ({
                token: configService. et<string>('DISCORD_BOT_TOKEN'),
                intents: [
                    IntentsBitField. uilds,
                    IntentsBitField. uildMessages,
                    IntentsBitField. irectMessages
                ]
            }),
            inject: [ConfigService]
        })
    ]
})
экспорт класса AppModule {}
```

В качестве альтернативы, вы можете настроить NestCordModule с помощью класса вместо фабрики, как показано ниже:

```typescript title="src/app.module.ts"
import { NestCordModule } from '@globalart/nestcord';
import { Module } from '@nestjs/common';
import { IntentsBitField } from 'discord. s';

@Module({
    imports: [
        NestCordModule. orRootAsync({
            useClass: NestCordConfigService
        })
    ]
})
экспорт класса AppModule {}
```

Сборка выше экземпляров `NestCordConfigService` внутри `NestCordModule`, используя его, чтобы создать необходимый объект параметров. Обратите внимание, что в этом примере `NestCordConfigService` должен реализовать интерфейс `NestCordOptionsFactory`, как показано ниже. `NestCordModule` вызовет метод `.createNestCordOptions()` в экземпляре объекта поставленного класса.

```typescript title="src/discord-config.service.ts"
import { Injectable } from '@nestjs/common';
import { NestCordOptionsFactory, NestCordModuleOptions } from '@globalart/nestcord';
import { IntentsBitField } from 'discord. s';

@Injectable()
класс NestCordConfigService {
    createNestCordOptions(): NestCordModuleOptions {
        return {
            token: 'DISCORD_BOT_TOKEN',
            intents: [
                IntentsBitField. uilds,
                IntentsBitField. uildMessages,
                IntentsBitField. irectMessages
            ]
        };
    }
}
```

Если вы хотите повторно использовать существующий поставщик опций вместо создания частной копии внутри `NestCordModule`, используйте синтаксис `useExisting`.
